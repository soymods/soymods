<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#1a1a1a" />

  <!-- Favicons -->
  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="/icon.png" sizes="32x32">
  <link rel="apple-touch-icon" href="/icon.png">

  <title>Pathmind — soymods</title>
  <meta name="description" content="Pathmind — a visual node-based editor for in-game workflows and intelligent behavior sequences." />

  <style>
    :root{
      --bg: rgb(26,26,26);
      --fg:#fff;
      --muted:rgba(255,255,255,.68);
      --muted2:rgba(255,255,255,.45);
      --line:rgba(255,255,255,.14);
      --line2:rgba(255,255,255,.26);
      --ease:cubic-bezier(.2,.8,.2,1);
      --max:1100px;
      --r:18px;
    }

    *{box-sizing:border-box}
    html,body{height:100%; background:var(--bg);}
    body{
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      letter-spacing:-0.01em;
      overflow-x:hidden;
    }

    a{color:inherit;text-decoration:none}
    a:focus-visible,button:focus-visible{
      outline:2px solid #fff;
      outline-offset:3px;
      border-radius:12px;
    }

    /* Flat-only overlays */
    .grid{
      position:fixed; inset:0;
      pointer-events:none;
      opacity:.9;
      background:
        repeating-linear-gradient(to right, transparent 0, transparent 39px, var(--line) 40px),
        repeating-linear-gradient(to bottom, transparent 0, transparent 39px, var(--line) 40px);
    }
    .dots{
      position:fixed; inset:0;
      pointer-events:none;
      opacity:.40;
      background-image: radial-gradient(circle, var(--line2) 1px, transparent 1px);
      background-size: 16px 16px;
      background-position: 10px 11px;
    }

    header{
      position:sticky; top:0; z-index:10;
      background: var(--bg);
      border-bottom:1px solid var(--line);
    }

    .wrap{max-width:var(--max); margin:0 auto; padding:16px 18px;}
    .nav{display:flex; align-items:center; justify-content:space-between; gap:14px;}
    .brand{display:inline-flex; align-items:center; gap:10px; font-weight:800; letter-spacing:-0.03em;}

    .logo{
      width:22px;
      height:22px;
      border-radius:7px;
      display:block;
      image-rendering:auto;
      object-fit:cover;
    }

    main{padding: 22px 0 64px; background:var(--bg);}

    .hero{
      position:relative;
      min-height: calc(100vh - 74px);
      display:grid;
      place-items:center;
      padding: 26px 0 10px;
    }

    .heroInner{
      width:min(920px, 100%);
      padding: 0 18px;
      text-align:center;
    }

    .word{
      margin:0;
      font-size: clamp(56px, 9vw, 120px);
      line-height: .9;
      letter-spacing: -0.06em;
      transform: translateY(10px);
      opacity:0;
      transition: transform .7s var(--ease), opacity .7s var(--ease);
    }
    .word.reveal{transform: translateY(0); opacity:1}

    .lede{
      margin: 14px auto 0;
      max-width: 72ch;
      color: var(--muted);
      font-size: 16px;
      line-height: 1.65;
      transform: translateY(10px);
      opacity:0;
      transition: transform .7s var(--ease), opacity .7s var(--ease);
    }
    .lede.reveal{transform: translateY(0); opacity:1}

    .actions{
      margin-top: 18px;
      display:flex;
      justify-content:center;
      flex-wrap:wrap;
      gap:10px;
      transform: translateY(10px);
      opacity:0;
      transition: transform .7s var(--ease), opacity .7s var(--ease);
    }
    .actions.reveal{transform: translateY(0); opacity:1}

    .btn{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:11px 14px;
      border-radius:999px;
      border:1px solid #fff;
      background:#fff;
      color:#000;
      font-weight:750;
      font-size:14px;
      cursor:pointer;
      transition: transform .18s var(--ease), opacity .18s var(--ease);
    }
    .btn.secondary{
      background:transparent;
      color:#fff;
      border-color:var(--line2);
    }
    .btn:hover{transform:translateY(-1px)}
    .btn.secondary:hover{border-color:#fff}

    /* Canvas */
    .canvas{
      width: min(980px, 100%);
      margin: 28px auto 0;
      border:1px solid var(--line);
      border-radius: calc(var(--r) + 10px);
      background: var(--bg);
      padding: 18px;
      position:relative;
      overflow:hidden;
      transform: translateY(10px);
      opacity:0;
      transition: transform .7s var(--ease), opacity .7s var(--ease);
    }
    .canvas.reveal{transform: translateY(0); opacity:1}

    .canvasTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      border-bottom:1px solid var(--line);
      padding-bottom: 12px;
      margin-bottom: 14px;
      background: var(--bg);
    }
    .canvasTop .meta{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      color:var(--muted2);
      font-size:12px;
    }
    .badge{
      padding:6px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      color:var(--muted);
      font-size:12px;
      background: var(--bg);
    }

    .nodes{
      position:relative;
      height: 220px;
      border:1px solid var(--line);
      border-radius: calc(var(--r) + 2px);
      overflow:hidden; /* keep wires inside box */
      background:transparent;
    }

    /* wires behind nodes */
    svg.wires{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      pointer-events:none;
      z-index:0;
    }

    /* colored nodes */
    .node{
      position:absolute;
      z-index:1;
      --accent:#fff;
      border:1px solid rgba(255,255,255,.22);
      border-radius: 16px;
      padding: 12px 14px;
      background: var(--bg);
      display:flex;
      align-items:center;
      gap:10px;
      cursor:grab;
      user-select:none;
      transition: border-color .18s var(--ease), transform .18s var(--ease);
    }
    .node::before{
      content:"";
      position:absolute;
      left:0; top:0; bottom:0;
      width:6px;
      background:var(--accent);
      border-top-left-radius:16px;
      border-bottom-left-radius:16px;
      opacity:.95;
    }
    .node:active{cursor:grabbing}
    .node:hover{border-color: rgba(255,255,255,.45)}

    .port{
      width: 10px; height: 10px;
      border-radius: 50%;
      border:1px solid rgba(255,255,255,.55);
      background:var(--accent);
      flex: 0 0 auto;
    }
    .node .name{font-weight:760; letter-spacing:-0.02em}
    .node .hint{color:var(--muted2); font-size:12px; margin-left:6px}

    .node[data-id="start"]{ --accent:#7CFFCB; }
    .node[data-id="mine"]{  --accent:#58A6FF; }
    .node[data-id="craft"]{ --accent:#FFB86B; }
    .node[data-id="place"]{ --accent:#FF5DA2; }

    /* info panels */
    .info{
      margin: 20px auto 0;
      width: min(980px, 100%);
      padding: 0 18px;
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap: 18px;
      background: var(--bg);
    }
    .panel{
      border:1px solid var(--line);
      border-radius: calc(var(--r) + 10px);
      padding: 18px;
      background: var(--bg);
    }
    .panel h2{
      margin:0;
      font-size:14px;
      letter-spacing:.08em;
      text-transform:uppercase;
      color:var(--muted);
    }
    .panel p{
      margin: 10px 0 0;
      color: var(--muted);
      line-height: 1.65;
      font-size: 14px;
    }
    .list{margin: 12px 0 0; padding:0; list-style:none; display:grid; gap:10px;}
    .li{border-top: 1px solid var(--line); padding-top: 10px; color: var(--muted); font-size: 14px; line-height: 1.55;}
    .li b{color:#fff}

    .kv{margin-top: 12px; display:grid; gap:10px;}
    .row{
      display:flex;
      justify-content:space-between;
      gap:10px;
      border:1px solid var(--line);
      border-radius: 14px;
      padding: 10px 12px;
      color: var(--muted);
      font-size: 13px;
      background: var(--bg);
    }
    .row span:last-child{color:#fff; font-weight:700}

    .panelVideo{
      margin-top: 14px;
      border:1px solid var(--line);
      border-radius: calc(var(--r) + 6px);
      overflow:hidden;
      background: var(--bg);
    }
    .panelVideoHead{
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      color:var(--muted);
      font-size:12px;
      letter-spacing:.08em;
      text-transform:uppercase;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      background: var(--bg);
    }
    .panelVideoHead b{
      color:#fff;
      font-weight:800;
      text-transform:none;
      letter-spacing:-0.01em;
      font-size:13px;
    }
    .panelVideoFrame{
      position:relative;
      width:100%;
      aspect-ratio:16/9;
      background: var(--bg);
    }
    .panelVideoFrame iframe{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      border:0;
    }

    footer{
      margin-top: 26px;
      border-top:1px solid var(--line);
      padding: 18px 18px 0;
      color:var(--muted2);
      font-size:13px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      max-width: var(--max);
      margin-left:auto;
      margin-right:auto;
      background: var(--bg);
    }
    footer a{color:var(--muted); border-bottom:1px solid transparent;}
    footer a:hover{color:#fff; border-color:rgba(255,255,255,.35)}

    @media (max-width: 900px){
      .info{grid-template-columns: 1fr;}
      .nodes{height: 260px;}
    }

    @media (prefers-reduced-motion: reduce){
      .word,.lede,.actions,.canvas{transition:none}
      .btn,.node{transition:none}
    }
  </style>
</head>
<body>
  <div class="grid" aria-hidden="true"></div>
  <div class="dots" aria-hidden="true"></div>

  <header>
    <div class="wrap nav">
      <a class="brand" href="/" aria-label="soymods home">
        <img class="logo" src="/icon.png" alt="" aria-hidden="true" />
        <span>soymods</span>
      </a>
      <div aria-hidden="true"></div>
    </div>
  </header>

  <main>
    <section class="hero">
      <div class="heroInner">
        <h1 class="word" id="w">Pathmind</h1>
        <p class="lede" id="l">
          A visual node-based editor for creating in-game workflows and intelligent behavior sequences — built to feel fast, readable, and deliberate.
        </p>

        <div class="actions" id="a">
          <a class="btn" href="https://github.com/soymods/pathmind/releases" target="_blank" rel="noreferrer">Download (GitHub Releases) ↗</a>
          <a class="btn secondary" href="https://github.com/soymods/pathmind/issues" target="_blank" rel="noreferrer">Report an issue ↗</a>
          <a class="btn secondary" href="mailto:contact@soymods.com">Email support</a>
        </div>

        <div class="canvas" id="c" aria-label="visual motif">
          <div class="canvasTop">
            <div class="meta">
              <span class="badge">Minecraft 1.21.x</span>
              <span class="badge">Fabric</span>
              <span class="badge">Client-side</span>
            </div>
            <span class="badge">by <span style="color:#fff; font-weight:800;">ryduzz</span></span>
          </div>

          <div class="nodes" id="nodes">
            <svg class="wires" id="wires" viewBox="0 0 1000 300" preserveAspectRatio="none" aria-hidden="true"></svg>

            <div class="node" data-id="start" style="left: 46px; top: 76px;">
              <span class="port" aria-hidden="true"></span>
              <span class="name">Start</span>
              <span class="hint">workflow</span>
            </div>
            <div class="node" data-id="mine" style="left: 330px; top: 44px;">
              <span class="port" aria-hidden="true"></span>
              <span class="name">Mine</span>
              <span class="hint">inputs</span>
            </div>
            <div class="node" data-id="craft" style="left: 600px; top: 112px;">
              <span class="port" aria-hidden="true"></span>
              <span class="name">Craft</span>
              <span class="hint">steps</span>
            </div>
            <div class="node" data-id="place" style="left: 812px; top: 64px;">
              <span class="port" aria-hidden="true"></span>
              <span class="name">Place</span>
              <span class="hint">output</span>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="info" aria-label="details">
      <div class="panel">
        <h2>What it is</h2>
        <p>
          Pathmind turns automation into a visual language: build workflows by connecting nodes, tune parameters, then execute sequences in-game.
          It’s designed to stay understandable even as graphs grow.
        </p>

        <ul class="list">
          <li class="li"><b>Node workflows</b> — connect actions into readable pipelines.</li>
          <li class="li"><b>Fast UI</b> — drag, connect, pan/zoom, iterate.</li>
          <li class="li"><b>Practical automation</b> — craft, place, mine, and more through a unified graph.</li>
        </ul>

        <!-- SWAPPED: What it is -> EBJEVciVAFU -->
        <div class="panelVideo" aria-label="What it is video">
          <div class="panelVideoHead">
            <b>Overview</b>
            <span>video</span>
          </div>
          <div class="panelVideoFrame">
            <iframe
              src="https://www.youtube.com/embed/EBJEVciVAFU"
              title="Overview video"
              loading="lazy"
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
              allowfullscreen>
            </iframe>
          </div>
        </div>
      </div>

      <div class="panel">
        <h2>Info</h2>
        <div class="kv">
          <div class="row"><span>Platform</span><span>Fabric</span></div>
          <div class="row"><span>Minecraft</span><span>1.21.x</span></div>
          <div class="row"><span>Environment</span><span>Client-side</span></div>
          <div class="row"><span>Downloads</span><span>GitHub Releases</span></div>
          <div class="row"><span>Support</span><span>GitHub Issues / Email</span></div>
        </div>
        <p style="margin-top:12px; color:var(--muted2);">
          Please use responsibly and follow server rules. You are responsible for how you use automation.
        </p>

        <!-- SWAPPED: Info -> 9MJRZGiwqbE -->
        <div class="panelVideo" aria-label="Info video">
          <div class="panelVideoHead">
            <b>Demo</b>
            <span>video</span>
          </div>
          <div class="panelVideoFrame">
            <iframe
              src="https://www.youtube.com/embed/9MJRZGiwqbE"
              title="Demo video"
              loading="lazy"
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
              allowfullscreen>
            </iframe>
          </div>
        </div>
      </div>
    </section>

    <footer>
      <div>© <span id="year"></span> soymods — Pathmind by ryduzz.</div>
      <div style="display:flex; gap:14px; flex-wrap:wrap;">
        <a href="/">soymods</a>
        <a href="https://github.com/soymods/pathmind/releases" target="_blank" rel="noreferrer">Releases</a>
        <a href="https://github.com/soymods/pathmind/issues" target="_blank" rel="noreferrer">Issues</a>
      </div>
    </footer>
  </main>

  <script>
    const reveal = () => {
      const w = document.getElementById('w');
      const l = document.getElementById('l');
      const a = document.getElementById('a');
      const c = document.getElementById('c');
      requestAnimationFrame(() => {
        w.classList.add('reveal');
        setTimeout(() => l.classList.add('reveal'), 110);
        setTimeout(() => a.classList.add('reveal'), 190);
        setTimeout(() => c.classList.add('reveal'), 270);
      });
    };

    const initGraph = () => {
      const container = document.getElementById('nodes');
      const svg = document.getElementById('wires');
      if (!container || !svg) return;

      const nodes = Array.from(container.querySelectorAll('.node'));
      const getRect = () => container.getBoundingClientRect();

      const setSvgView = () => {
        const r = getRect();
        svg.setAttribute('viewBox', `0 0 ${Math.max(1, r.width)} ${Math.max(1, r.height)}`);
      };

      // port center in container coords (used for direction)
      const portCenter = (node) => {
        const port = node.querySelector('.port') || node;
        const pr = port.getBoundingClientRect();
        const cr = getRect();
        return {
          x: (pr.left - cr.left) + pr.width / 2,
          y: (pr.top - cr.top) + pr.height / 2
        };
      };

      // Node rect in container coords
      const nodeRect = (node) => {
        const r = node.getBoundingClientRect();
        const cr = getRect();
        return {
          left: r.left - cr.left,
          top: r.top - cr.top,
          right: (r.left - cr.left) + r.width,
          bottom: (r.top - cr.top) + r.height
        };
      };

      // Intersect segment p0->p1 with node rectangle boundary.
      // Returns the first hit point entering the rectangle when traveling from p0 to p1.
      const intersectRectBoundary = (p0, p1, rect) => {
        const dx = p1.x - p0.x;
        const dy = p1.y - p0.y;

        // avoid divide-by-zero
        const eps = 1e-9;
        const candidates = [];

        // x = left/right
        if (Math.abs(dx) > eps) {
          let t = (rect.left - p0.x) / dx;
          if (t >= 0 && t <= 1) {
            const y = p0.y + t * dy;
            if (y >= rect.top && y <= rect.bottom) candidates.push({ t, x: rect.left, y });
          }
          t = (rect.right - p0.x) / dx;
          if (t >= 0 && t <= 1) {
            const y = p0.y + t * dy;
            if (y >= rect.top && y <= rect.bottom) candidates.push({ t, x: rect.right, y });
          }
        }

        // y = top/bottom
        if (Math.abs(dy) > eps) {
          let t = (rect.top - p0.y) / dy;
          if (t >= 0 && t <= 1) {
            const x = p0.x + t * dx;
            if (x >= rect.left && x <= rect.right) candidates.push({ t, x, y: rect.top });
          }
          t = (rect.bottom - p0.y) / dy;
          if (t >= 0 && t <= 1) {
            const x = p0.x + t * dx;
            if (x >= rect.left && x <= rect.right) candidates.push({ t, x, y: rect.bottom });
          }
        }

        // pick the closest intersection to p0 (smallest positive t)
        candidates.sort((a,b) => a.t - b.t);
        return candidates.length ? { x: candidates[0].x, y: candidates[0].y } : { x: p1.x, y: p1.y };
      };

      // Clip endpoints so wires stop at node outlines, not inside nodes
      const clipToNode = (fromOutside, toInside, node) => {
        const rect = nodeRect(node);
        // move endpoints a tiny bit outward so the stroke doesn't peek inside on some zoom levels
        const hit = intersectRectBoundary(fromOutside, toInside, rect);
        return hit;
      };

      const clampInitialPositions = () => {
        const bounds = getRect();
        nodes.forEach(node => {
          const w = node.offsetWidth;
          const h = node.offsetHeight;
          let left = parseFloat(node.style.left || '0');
          let top  = parseFloat(node.style.top  || '0');
          left = Math.max(8, Math.min(left, bounds.width  - w - 8));
          top  = Math.max(8, Math.min(top,  bounds.height - h - 8));
          node.style.left = left + 'px';
          node.style.top  = top  + 'px';
        });
      };

      const layoutNodes = () => {
        const bounds = getRect();
        if (!bounds.width) return;

        const ordered = nodes.slice();
        const widths = ordered.map(n => n.offsetWidth);
        const totalW = widths.reduce((a,b) => a + b, 0);
        const padding = 8;
        const usable = Math.max(0, bounds.width - padding * 2);
        const gap = (usable > totalW && ordered.length > 1)
          ? (usable - totalW) / (ordered.length - 1)
          : 10;

        let x = padding;
        ordered.forEach((node, i) => {
          node.style.left = x + 'px';
          x += widths[i] + gap;
        });
      };

      const draw = () => {
        setSvgView();

        const pairs = [['start','mine'],['mine','craft'],['craft','place']];
        const byId = Object.fromEntries(nodes.map(n => [n.dataset.id, n]));

        svg.innerHTML = '';
        pairs.forEach(([a,b]) => {
          const na = byId[a];
          const nb = byId[b];
          if (!na || !nb) return;

          // "raw" points (inside nodes) for direction
          const paIn = portCenter(na);
          const pbIn = portCenter(nb);

          // clip endpoints to the node outlines
          const pa = clipToNode(pbIn, paIn, na); // coming from B -> A
          const pb = clipToNode(paIn, pbIn, nb); // coming from A -> B

          const dx = Math.max(40, Math.abs(pb.x - pa.x) * 0.45);
          const c1x = pa.x + dx;
          const c2x = pb.x - dx;
          const d = `M ${pa.x} ${pa.y} C ${c1x} ${pa.y}, ${c2x} ${pb.y}, ${pb.x} ${pb.y}`;

          const glow = document.createElementNS('http://www.w3.org/2000/svg','path');
          glow.setAttribute('d', d);
          glow.setAttribute('fill','none');
          glow.setAttribute('stroke','rgba(255,255,255,.10)');
          glow.setAttribute('stroke-width','6');
          glow.setAttribute('stroke-linecap','round');

          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          path.setAttribute('d', d);
          path.setAttribute('fill','none');
          path.setAttribute('stroke','rgba(255,255,255,.45)');
          path.setAttribute('stroke-width','1.5');
          path.setAttribute('stroke-linecap','round');

          svg.appendChild(glow);
          svg.appendChild(path);
        });
      };

      let active = null;
      let userMoved = false;
      let startX = 0, startY = 0;
      let nodeStartLeft = 0, nodeStartTop = 0;

      const onDown = (e, node) => {
        userMoved = true;
        active = node;
        const st = window.getComputedStyle(node);
        nodeStartLeft = parseFloat(st.left || '0');
        nodeStartTop = parseFloat(st.top || '0');
        startX = e.clientX;
        startY = e.clientY;
        node.setPointerCapture?.(e.pointerId);
      };

      const onMove = (e) => {
        if (!active) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        const bounds = getRect();

        const w = active.offsetWidth;
        const h = active.offsetHeight;

        let left = nodeStartLeft + dx;
        let top  = nodeStartTop + dy;

        left = Math.max(8, Math.min(left, bounds.width - w - 8));
        top  = Math.max(8, Math.min(top,  bounds.height - h - 8));

        active.style.left = left + 'px';
        active.style.top  = top  + 'px';
        draw();
      };

      const onUp = () => { active = null; };

      nodes.forEach(node => node.addEventListener('pointerdown', (e) => onDown(e, node)));
      window.addEventListener('pointermove', onMove, { passive: true });
      window.addEventListener('pointerup', onUp);

      window.addEventListener('resize', () => {
        if (!userMoved) layoutNodes();
        clampInitialPositions();
        draw();
      });

      requestAnimationFrame(() => {
        layoutNodes();
        clampInitialPositions();
        draw();
      });
    };

    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('year').textContent = new Date().getFullYear();
      reveal();
      initGraph();
    });
  </script>
</body>
</html>
